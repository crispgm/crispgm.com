<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <meta name="description" content="A minimalist programmer, photographer and lifes lover."/>
    <title>贴吧 BigPipe 实践 (nginx + hhvm) | David Zhang</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="canonical" href="https://crispgm.com/page/bigpipe-practice.html">
    <link rel="alternate" href="https://crisp.lol/page/bigpipe-practice.html">
    <link rel="alternate" href="https://crispgm.com/feed.xml" type="application/rss+xml" title="RSS">
    <link href="//fonts.googleapis.com/css?family=Noto+Sans" rel="stylesheet">
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet">
    <link href="//fonts.googleapis.com/css?family=Crimson+Text:400,400italic&amp;subset=latin,latin-ext" rel="stylesheet">
    <link rel="icon" type="image/x-icon" href="/image/logo.png">
    
    <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/animatecss/3.5.2/animate.min.css">
    
    <link rel="stylesheet" href="/assets/css/tomorrow-night-eighties.css">
    
    
    <link rel="stylesheet" href="/assets/css/style.css">
  </head>
  <body>
    <div class="content" id="header">
          <header class="content-wrapper menu">
      <div class="menu-links">
        <div class="menu-item">
          <a href="/blog.html">Blog</a>
        </div>
        <div class="menu-item">
          <a href="/project.html">Project</a>
        </div>
        <div class="menu-item">
          <a href="/wiki/">Wiki</a>
        </div>
        <div class="menu-item">
          <a href="/things.html">Things</a>
        </div>
        <div class="menu-item">
          <a href="/bio.html">Bio</a>
        </div>
        <div class="menu-item">
          <a href="/about.html">About</a>
        </div>
      </div>
      <div class="menu-bars">
        <i id="dropdown-button" class="fa fa-bars"></i>
      </div>
      <div class="menu-home">
        <a href="/">DAVID ZHANG</a>
      </div>
    </header>

    </div>
    <div class="content" id="main-content">
      <div class="content-wrapper">
        <div class="article">
  <div class="article-head">
    <div class="article-title">贴吧 BigPipe 实践 (nginx + hhvm)</div>
    <div class="article-date">June 26, 2015</div>
  </div>
  <div class="article-main">
    <h2 id="背景">背景</h2>

<p>随着 Web 页面的功能不断堆砌（其实我是极简主义者，但PM或者说是国内的风气，总是喜欢不断加入各类功能），页面需要的数据越来越多，串行连接后端的耗时自然是不断增大。常见的优化手段就是后端并行化，而对于前端来说，后端并行化只是降低了 response time，但用户最终看到页面的时间并没有减少。</p>

<p>Facebook 提出了 BigPipe 的方案，将页面功能分块，分成若干个 pagelet。Pagelet 的加载使用了 http 的 chunked 特性，采用类似 Pipeline 的方式进行前后端数据传输。浏览器端会首先获得一个框架层的 HTML/css，以及基础 JavaScript 代码。同时，后端也可以进行并行化，每个 pagelet 完成后，通过 flush 输出到浏览器。浏览器端的 JavaScript 基于事件机制，收到数据后进行渲染。</p>

<p>这样，前后端就可以都做到并行化，用户可以先看到部分页面内容，从而获得了更好的用户体验。目前，国外主要是 Facebook 应用了这项技术，而国内微博也通过 BigPipe 获得了不错的效果。</p>

<p><img src="/image/fb-bigpipe.png" alt="Facebook-BigPipe" /></p>

<p>图：Facebook 加载时的 timing，可以看到 waiting 时间（也就是后端响应时间 response time）明显低于 content download 耗时。</p>

<h2 id="简单-demo">简单 Demo</h2>

<div class="language-php highlighter-rouge"><pre class="highlight"><code>echo 'hello';
flush();
ob_flush();
sleep(1);
echo 'world';
</code></pre>
</div>

<p>这是一个最简单的 BigPipe demo，然而由于 <code class="highlighter-rouge">fastcgi_buffer</code> 的存在，并不能看到分段输出的效果。那么，我们把程序进行一下改动，用 <code class="highlighter-rouge">str_pad</code> 填充一些字符以达到 buffer。ps：吐槽一下 <code class="highlighter-rouge">str_pad</code> 这个函数名，明明 str 系列函数都是不带下划线的，如 <code class="highlighter-rouge">strlen</code>, <code class="highlighter-rouge">strcpy</code> 等，但这个函数却有下划线。str 系列函数表示：我们之间出现了叛徒！</p>

<div class="language-php highlighter-rouge"><pre class="highlight"><code>echo str_pad('hello', 10000, ' ');
flush();
ob_flush();
sleep(1);
echo str_pad('world', 10000, ' ');
</code></pre>
</div>

<p>进行字符填充后，BigPipe 效果显现了出来，hello 之后过1秒后会才会出现 world。由此可见，buffer 这块是个问题，后面会单独具体介绍科学优雅的解决方法。</p>

<h2 id="实践">实践</h2>

<h3 id="整体设计">整体设计</h3>

<p>BigPipe 的整体方案是需要具体实现环节分为如下几部分：</p>

<ol>
  <li>BigPipe 框架。包括前端和后端两部分，以及对于不支持 BigPipe 模式的流量启用的降级模式。此外，为了便于 SEO，对于搜索引擎 Spider 的抓取也要使用降级模式。</li>
  <li>Pagelet 和 DataProvider 管理维护制度。这是一项管理上的措施，主要是为了管理 Pagetlet、DataProvider 以及其之间的依赖关系。</li>
  <li>BigPipe 调试工具。由于在 BigPipe 开发模式中，后端开发负责 DataProvider，前端人员负责 Pagelet，双方需要调试工具进行独立开发调试。</li>
</ol>

<h3 id="潜在问题">潜在问题</h3>

<ol>
  <li>页面交叉调用过多，导致分段输出效果并不好</li>
  <li>前端的误调用会影响后端的响应时间</li>
  <li>后端性能优化需要前端配合</li>
</ol>

<h3 id="异步并行框架">异步并行框架</h3>

<p>由于贴吧现有框架本身并不支持纯异步调用，只支持阻塞并行的远程调用(ral_multi)，其响应时间为：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>t = max(t1, t2, t3...)
</code></pre>
</div>

<p>框架本身需要升级，在升级完成前需要基于现有架构模拟纯异步，并且要在框架支持纯异步后，平滑对 DataProvider 透明地迁移成纯异步模式。</p>

<p>因此，BigPipe 并行框架采用异步-回调模式，通过状态机模拟异步过程。状态机会以深度优先遍历 DataProvider 以及其依赖的 DataProvider，并初始化成 <code class="highlighter-rouge">INITIAL</code> 状态。没有依赖的 DataProvider 会直接执行，进入 <code class="highlighter-rouge">EXECUTING</code> 状态。当一个有依赖的 DataProvider 的依赖已经全部处于 <code class="highlighter-rouge">READY</code> 状态时，则会同一般的 DataProvider 一样 <code class="highlighter-rouge">execute</code> 执行。<code class="highlighter-rouge">execute</code> 函数中会有数据交互和业务逻辑处理，当处理完毕后需要主动调用 <code class="highlighter-rouge">ready</code> 函数将 DataProvider 自身置为 <code class="highlighter-rouge">READY</code>。</p>

<p>Pagelet 依赖的 DataProvider 都 <code class="highlighter-rouge">READY</code> 后，就会渲染页面。</p>

<h3 id="buffer问题">Buffer问题</h3>

<p>由于“各路” buffer 的存在，如果包比较小的话 BigPipe 的 chunked 输出很可能会被 buffer 住。针对这种情况，一般来说有两种方式。</p>

<ol>
  <li>使用 <code class="highlighter-rouge">str_pad</code> 这类函数进行填充，如：填充空格。永远将一次 flush 的数据填充到 <code class="highlighter-rouge">buffer_size</code>。</li>
  <li>调小 buffer，让数据更容易达到 <code class="highlighter-rouge">buffer_size</code>。</li>
  <li>关闭 buffer。</li>
</ol>

<p>对于 Nginx 来说，会有 <code class="highlighter-rouge">proxy_buffer</code> 和 <code class="highlighter-rouge">fastcgi_buffer</code>。第一种方式，不用调整 buffer，但这种方式很不优雅，而且增加了带宽，并不是很合理。至于调小 buffer，这看起来是一个很好的思路，然而对于 gzip 过的数据来说，最小的 buffer 可能也比较大。因此，我们选择了关闭 <code class="highlighter-rouge">proxy_buffer</code> 和 <code class="highlighter-rouge">fastcgi_buffer</code>。</p>

<p>然而，这样带来了一个问题。线上运行中的 Nginx 1.4.4版本过低，关闭 <code class="highlighter-rouge">proxy_buffer</code> 的指令 <code class="highlighter-rouge">proxy_buffering off</code> 原生就支持。而关闭 <code class="highlighter-rouge">fastcgi_buffer</code> 的 <code class="highlighter-rouge">fastcgi_buffering</code> 需要1.5.6版本。所以首先，我们把 Nginx 版本升级到了1.7.8，重编译后上线。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Syntax: fastcgi_buffering on | off;
Default: fastcgi_buffering on;
Context: http, server, location
This directive appeared in version 1.5.6.
</code></pre>
</div>

<p>详见 <a href="http://nginx.org/en/docs/http/ngx_http_fastcgi_module.html#fastcgi_buffering">http://nginx.org/en/docs/http/ngx_http_fastcgi_module.html#fastcgi_buffering</a></p>

<div class="highlighter-rouge"><pre class="highlight"><code># 旧版本的Nginx并不支持fastcgi_buffering
nginx: [emerg] unknown directive "fastcgi_buffering"
</code></pre>
</div>

<p>还有一个问题，就是我们并不想对所有请求都关闭 buffer。为了将影响面做得最小，我们只想关闭特定模块的 buffer。改 <code class="highlighter-rouge">nginx.conf</code> 固然可以实现，不过对于不支持嵌套 <code class="highlighter-rouge">if</code> 的 <code class="highlighter-rouge">nginx.conf</code> 来说这是个很不舒服的用法。</p>

<p>幸好，在升级的过程中，发现了一个刚好可以用 http header，用于关闭 buffer。</p>

<blockquote>
  <p>Buffering can also be enabled or disabled by passing “yes” or “no” in the “X-Accel-Buffering” response header field. This capability can be disabled using the fastcgi_ignore_headers directive.</p>
</blockquote>

<p>因此，配置上完全不用关闭 buffer，只需要在 php 代码中加 header 就好，顺利把 buffer 优雅关闭。</p>

<div class="language-php highlighter-rouge"><pre class="highlight"><code>header('X-Accel-Buffering: no');
</code></pre>
</div>

<h3 id="效果评估">效果评估</h3>

<ul>
  <li>TTFB时间减少56% (TTFB = time to first byte)</li>
  <li>白屏时间减少59%</li>
  <li>降低了局部刷新开发成本</li>
</ul>

<h3 id="其它总结">其它总结</h3>

<ul>
  <li>开发迁移时间超长，从立项到上线总共持续了半年，前端主要开发人员因为离职等原因换了三波</li>
  <li>底层本质上还无法并发，优化效果远远不够彻底</li>
  <li>pagelet 交叉请求比较多，效果没有那么好</li>
</ul>

  </div>
  
  <hr>
  <div class="article-tag">
    
    <div class="tag-item">
    BigPipe
    </div>
    
    <div class="tag-item">
    nginx
    </div>
    
    <div class="tag-item">
    hhvm
    </div>
    
    <div class="tag-item">
    php
    </div>
    
  </div>
  
  <div id="disqus_thread"></div>
  <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
</div>

      </div>
    </div>
        <footer>
      <div class="content-wrapper" id="contact">
        <div id="links">
          <a href="mailto:crispgm@gmail.com"><i class="fa fa-envelope-o"></i></a>
          <a href="/feed.xml"><i class="fa fa-rss"></i></a>
          <a href="https://github.com/crispgm"><i class="fa fa-github"></i></a>
          <a href="https://stackoverflow.com/users/6858150/david-zhang/"><i class="fa fa-stack-overflow"></i></a>
          <a href="https://instagram.com/crispgm"><i class="fa fa-instagram"></i></a>
          <a href="https://twitter.com/crispgm"><i class="fa fa-twitter"></i></a>
          <a href="http://medium.com/@crispgm"><i class="fa fa-medium"></i></a>
          <a href="https://www.linkedin.com/in/wanlong-zhang"><i class="fa fa-linkedin"></i></a>
        </div>

        <div id="copyright">
          David Zhang &copy; 2017
        </div>
      </div>
    </footer>
    <script>
      document.addEventListener('DOMContentLoaded', function() {
        isToggle = false;

        document.body.addEventListener("click", function(evt){
          if (isToggle && evt.target.id != 'dropdown-button') {
            toggleMenu();
          }
        });

        var dropdown = document.querySelector("#dropdown-button");
        dropdown.addEventListener("click", function(evt) {
          toggleMenu();
        });

        document.body.addEventListener("touchstart", function(evt){
          evt.stopPropagation();
        });
      }, false);

      function toggleMenu() {
        var menuElement = document.querySelector(".menu-links");
        var dropdownElement = document.querySelector("#dropdown-button");
        if (isToggle) {
          menuElement.classList.remove("menu-dropdown");
          menuElement.classList.remove("animated");
          menuElement.classList.remove("fadeIn");
          dropdownElement.classList.remove("fa-close");
          dropdownElement.classList.remove("fa-inverse");
          dropdownElement.classList.add("fa-bars");
        }
        else {
          menuElement.classList.add("menu-dropdown");
          menuElement.classList.add("animated");
          menuElement.classList.add("fadeIn");
          dropdownElement.classList.remove("fa-bars");
          dropdownElement.classList.add("fa-close");
          dropdownElement.classList.add("fa-inverse");
        }
        isToggle = !isToggle;
      }
    </script>
    
    <script src="/assets/scripts/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-50708664-1', 'auto');
      ga('send', 'pageview');
    </script>
    
    <script>
    var disqus_config = function () {
      this.page.identifier = '/page/bigpipe-practice.html';
    };
    
    (function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = 'https://crispgm.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
    })();
    </script>
    
  </body>
</html>