<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <meta name="keywords" content="crisp, crispgm, Crisp Blog, David Zhang, Crisp博客, yeyeko, 椰椰子"/>
        <meta name="description" content="Crisp Blog, personal blog of David 'Crisp' Zhang. Focus on programming(web development, nginx, php and etc.), minimalism and Apple Devices. Crisp个人博客,主要专注于程序设计(包括Web开发/nginx/PHP等),极简主义和苹果设备."/>
        <title>BigPipe实践(nginx+hhvm) - Crisp Blog</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="stylesheet" href="/style/style.css" media="screen">
        <link rel="stylesheet" href="/style/mobile.css" media="screen and (max-width: 800px)">
        <link rel="stylesheet" href="/style/vs.css">
        <link rel="stylesheet" href="/style/opensans.css">
        <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
        <script src="/script/highlight.pack.js"></script>
        <script src="/script/jquery-2.0.3.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script>
    </head>
    <body>
        <div id="menu">
            <div id="menu_home">
                <a href="/">Crisp Blog</a>
            </div>
            <div id="menu_links">
                <a href="/page/about.html">
                    <i title="About" class="fa fa-user fa-lg"></i>
                </a>
                <a href="http://yeyekooo.crispgm.com">
                    <i title="Yeyeko" class="fa fa-heart-o fa-lg"></i>
                </a>
                <a href="#">
                    <i title="Photo" class="fa fa-picture-o fa-lg"></i>
                </a>
                <a href="http://crispgm.com:8888">
                    <i title="google for crisp" class="fa fa-google fa-lg"></i>
                </a>
                <!---
                <a href="/archive.html">
                    <i title="Archive" class="fa fa-folder-o fa-lg"></i>
                </a>
                -->
                <a href="/rss.xml" target="_blank">
                    <i title="RSS Feed" class="fa fa-rss fa-lg"></i>
                </a>
                <a href="http://github.com/crispgm" target="_blank">
                    <i title="GitHub" class="fa fa-github fa-lg"></i>
                </a>
                <a href="http://instagram.com/crispgm" target="_blank">
                    <i title="Instagram" class="fa fa-instagram fa-lg"></i>
                </a>
                <a href="http://weibo.com/crispgm" target="_blank">
                    <i title="Weibo" class="fa fa-weibo fa-lg"></i>
                </a>
            </div>
        </div>
    </div>
    <div id="container">

<div class="article"><div class="article_head"><div class="article_title">BigPipe实践(nginx+hhvm)</div>
<div class="article_date">2015/06/26</div>
</div><div class="article_main"><h2>背景</h2>
<p>随着Web页面的功能不断堆砌（其实我是极简主义者，但PM或者说是国内的风气，总是喜欢不断加入各类功能），页面需要的数据越来越多，串行连接后端的耗时自然是不断增大。常见的优化手段就是后端并行化，而对于前端来说，后端并行化只是降低了response time，但用户最终看到页面的时间并没有减少。</p>
<p>Facebook提出了BigPipe的方案，讲页面功能分块，分成若干个pagelet。pagelet的加载使用了http的chunked特性，采用类似Pipeline的方式进行前后端数据传输。浏览器端会首先获得一个框架层的HTML/css，以及基础js代码。同时，后端也可以进行并行化，每个pagelet完成后，通过flush输出到浏览器。浏览器端的js基于事件机制，收到数据后进行渲染。</p>
<p>这样，前后端就可以都做到并行化，用户可以先看到部分页面内容，从而获得了更好的用户体验。目前，国外主要是Facebook应用了这项技术，而国内微博也通过BigPipe获得了不错的效果。</p>
<p><img alt="Facebook-BigPipe" src="http://crispgm.com/image/fb-bigpipe.png" /></p>
<p>图：Facebook加载时的timing，可以看到waiting时间（也就是后端响应时间response time）明显低于content download耗时。</p>
<h2>简单Demo</h2>
<pre><code class="language-php">    echo 'hello';
    flush();
    ob_flush();
    sleep(1);
    echo 'world';</code></pre>
<p>这是一个最简单的BigPipe demo，然而由于fastcgi_buffer的存在，并不能看到分段输出的效果。那么，我们把程序进行一下改动，用str_pad填充一些字符以达到buffer。ps：吐槽一下str_pad这个函数名，明明str系列函数都是不带下划线的，如strlen, strcpy等，但这个函数却有下划线。str系列函数表示：我们之间出现了叛徒！</p>
<pre><code class="language-php">    echo str_pad('hello', 10000, ' ');
    flush();
    ob_flush();
    sleep(1);
    echo str_pad('world', 10000, ' ');</code></pre>
<p>进行字符填充后，BigPipe效果显现了出来，hello之后过1秒后会才会出现world。由此可见，buffer这块是个问题，后面会单独具体介绍科学优雅的解决方法。</p>
<h2>实践</h2>
<h3>整体设计</h3>
<p>BigPipe的整体方案是，</p>
<p>TODO</p>
<p>具体实现环节分为如下几部分：</p>
<ol>
<li>BigPipe框架。包括前端和后端两部分，以及对于不支持BigPipe模式的流量器启用的降级模式。此外，为了便于SEO，对于搜索引擎Spider的抓取也要使用降级模式。</li>
<li>Pagelet和DataProvider管理维护制度。这是一项管理上的措施，主要是为了管理Pagetlet、DataProvider以及其之间的依赖关系。</li>
<li>BigPipe调试工具。由于在BigPipe开发模式中，后端开发负责DataProvider，前端人员负责Pagelet，双方需要调试工具进行独立开发调试。</li>
</ol>
<h3>潜在问题</h3>
<ol>
<li>页面交叉调用过多，导致pipe输出效果并不好</li>
<li>前端的误调用会影响后端的响应时间</li>
<li>后端性能优化需要前端配合</li>
</ol>
<h3>异步并行框架</h3>
<p>由于贴吧现有框架本身并不支持纯异步调用，只支持阻塞并行的远程调用(ral_multi)，其响应时间为：</p>
<pre><code>    t = max(t1, t2, t3...)</code></pre>
<p>框架本身需要升级，在升级完成前需要基于现有架构模拟纯异步，并且要在框架支持纯异步后，平滑对DataProvider透明地迁移成纯异步模式。</p>
<p>因此，BigPipe并行框架采用异步-回调模式，通过状态机模拟异步过程。</p>
<p>TODO</p>
<h3>Buffer问题</h3>
<p>由于“各路”buffer的存在，如果包比较小的话BigPipe的chunked输出很可能会被buffer住。针对这种情况，一般来说有两种方式。</p>
<ol>
<li>使用strpad这类函数进行填充，如：填充空格。永远将一次flush的数据填充到buffer_size。</li>
<li>调小buffer，让数据更容易达到buffer_size。</li>
<li>关闭buffer。</li>
</ol>
<p>对于Nginx来说，会有proxy_buffer和fastcgi_buffer。第一种方式，不用调整buffer，但这种方式很不优雅，而且增加了带宽，并不是很合理。至于调小buffer，这看起来是一个很好的思路，然而对于gzip过的数据来说，最小的buffer可能也比较大。因此，我们选择了关闭proxy_buffer和fastcgi_buffer。</p>
<p>然而，这样带来了一个问题。线上运行中的Nginx 1.4.4版本过低，关闭proxy_buffer的指令proxy_buffering off原生就支持。而关闭fastcgi_buffer的fastcgi_buffering需要1.5.6版本。所以首先，我们把Nginx版本升级到了1.7.8，重编译后上线。</p>
<pre><code>    Syntax: fastcgi_buffering on | off;
    Default:    
    fastcgi_buffering on;
    Context:    http, server, location
    This directive appeared in version 1.5.6.</code></pre>
<p>详见<a href="http://nginx.org/en/docs/http/ngx_http_fastcgi_module.html#fastcgi_buffering"><a href="http://nginx.org/en/docs/http/ngx_http_fastcgi_module.html#fastcgi_buffering">http://nginx.org/en/docs/http/ngx_http_fastcgi_module.html#fastcgi_buffering</a></a></p>
<pre><code>    # 旧版本的Nginx并不支持fastcgi_buffering
    nginx: [emerg] unknown directive "fastcgi_buffering"</code></pre>
<p>还有一个问题，就是我们并不想对所有请求都关闭buffer。为了将影响面做得最小，我们只想关闭特定模块的buffer。改nginx.conf固然可以实现，不过对于不支持嵌套if的nginx.conf来说这是个很不舒服的用法。</p>
<p>幸好，在升级的过程中，发现了一个刚好可以用http header，用于关闭buffer。</p>
<blockquote>
<p>Buffering can also be enabled or disabled by passing “yes” or “no” in the “X-Accel-Buffering” response header field. This capability can be disabled using the fastcgi_ignore_headers directive.</p>
</blockquote>
<p>因此，配置上完全不用关闭buffer，只需要在php代码中加header就好，顺利把buffer优雅关闭。</p>
<pre><code class="language-php">    header('X-Accel-Buffering: no');</code></pre>
<h3>效果评估</h3>
<p>TODO</p></div>
</div>
    <div id="disqus_thread"></div>
    <script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    
    var disqus_shortname = 'crispgm'; // required: replace example with your forum shortname
    
    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

</div>
<footer>
Copyright &copy; David Zhang, 2015.
</footer>
<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-50708664-1', 'crispgm.com');
ga('send', 'pageview');
</script>
</body>
</html>

