<!DOCTYPE html>
<html>
  <head>
  <meta charset="UTF-8">
  <meta name="description" content="Home page and blog of David Zhang (@crispgm), a minimalist programmer, photographer, and lifehacker."/>
  <title>贴吧 BigPipe 实践 (nginx + hhvm) | CrispDev</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta property="og:site_name" content="Crisp.Dev">
  <meta property="og:image" content="https://crisp.dev/image/social-share-img.jpg">
  <meta property="twitter:card" content="summary_large_image">
  <link rel="canonical" href="https://crispgm.com/page/bigpipe-practice.html">
  
  <link rel="alternate" href="https://crisp.dev/page/bigpipe-practice.html">
  
  <link rel="alternate" href="https://crispgm.com/feed.xml" type="application/rss+xml" title="RSS">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Fira+Sans|Fira+Mono&display=swap">
  <link rel="icon" type="image/x-icon" href="/image/logo.png">
  
  <link rel="stylesheet" href="/assets/css/font.css?v=1667562008">
  
  
  <link rel="stylesheet" href="/assets/css/nord.css">
  
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css" crossorigin="anonymous">
  
  <link rel="stylesheet" href="/assets/css/style.css">
  <script src="https://use.typekit.net/syr2mmc.js"></script>
  <script>try{Typekit.load({ async: true });}catch(e){}</script>
</head>

  <body>
    <div class="progress-bar"></div>
    <div class="wrapper blog-wrapper content-wrapper">
      <div class="article">
        <div class="article-menu">
          <div class="article-home">
            <a href="/">CrispDev</a>
          </div>
          <div class="article-back">
            <a href="/blog.html"><< Back</a>
          </div>
        </div>
        <div class="article-head">
          <div class="article-title">
            贴吧 BigPipe 实践 (nginx + hhvm)
          </div>
          <div class="article-date">
            <time datetime="2015-06-26 08:23:00 +0000">June 26, 2015</time>
          </div>
        </div>
        <div class="article-main">
          <h2 id="背景">背景</h2>

<p>随着 Web 页面的功能不断堆砌（其实我是极简主义者，但PM或者说是国内的风气，总是喜欢不断加入各类功能），页面需要的数据越来越多，串行连接后端的耗时自然是不断增大。常见的优化手段就是后端并行化，而对于前端来说，后端并行化只是降低了 response time，但用户最终看到页面的时间并没有减少。</p>

<p>Facebook 提出了 BigPipe 的方案，将页面功能分块，分成若干个 pagelet。Pagelet 的加载使用了 http 的 chunked 特性，采用类似 Pipeline 的方式进行前后端数据传输。浏览器端会首先获得一个框架层的 HTML/css，以及基础 JavaScript 代码。同时，后端也可以进行并行化，每个 pagelet 完成后，通过 flush 输出到浏览器。浏览器端的 JavaScript 基于事件机制，收到数据后进行渲染。</p>

<p>这样，前后端就可以都做到并行化，用户可以先看到部分页面内容，从而获得了更好的用户体验。目前，国外主要是 Facebook 应用了这项技术，而国内微博也通过 BigPipe 获得了不错的效果。</p>

<p><img src="https://crispgm.com/image/fb-bigpipe.png" alt="Facebook-BigPipe" /></p>

<p>图：Facebook 加载时的 timing，可以看到 waiting 时间（也就是后端响应时间 response time）明显低于 content download 耗时。</p>

<h2 id="简单-demo">简单 Demo</h2>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">echo</span> <span class="s1">'hello'</span><span class="p">;</span>
<span class="nb">flush</span><span class="p">();</span>
<span class="nb">ob_flush</span><span class="p">();</span>
<span class="nb">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="k">echo</span> <span class="s1">'world'</span><span class="p">;</span>
</code></pre></div></div>

<p>这是一个最简单的 BigPipe demo，然而由于 <code class="language-plaintext highlighter-rouge">fastcgi_buffer</code> 的存在，并不能看到分段输出的效果。那么，我们把程序进行一下改动，用 <code class="language-plaintext highlighter-rouge">str_pad</code> 填充一些字符以达到 buffer。ps：吐槽一下 <code class="language-plaintext highlighter-rouge">str_pad</code> 这个函数名，明明 str 系列函数都是不带下划线的，如 <code class="language-plaintext highlighter-rouge">strlen</code>, <code class="language-plaintext highlighter-rouge">strcpy</code> 等，但这个函数却有下划线。str 系列函数表示：我们之间出现了叛徒！</p>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">echo</span> <span class="nb">str_pad</span><span class="p">(</span><span class="s1">'hello'</span><span class="p">,</span> <span class="mi">10000</span><span class="p">,</span> <span class="s1">' '</span><span class="p">);</span>
<span class="nb">flush</span><span class="p">();</span>
<span class="nb">ob_flush</span><span class="p">();</span>
<span class="nb">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="k">echo</span> <span class="nb">str_pad</span><span class="p">(</span><span class="s1">'world'</span><span class="p">,</span> <span class="mi">10000</span><span class="p">,</span> <span class="s1">' '</span><span class="p">);</span>
</code></pre></div></div>

<p>进行字符填充后，BigPipe 效果显现了出来，hello 之后过1秒后会才会出现 world。由此可见，buffer 这块是个问题，后面会单独具体介绍科学优雅的解决方法。</p>

<h2 id="实践">实践</h2>

<h3 id="整体设计">整体设计</h3>

<p>BigPipe 的整体方案是需要具体实现环节分为如下几部分：</p>

<ol>
  <li>BigPipe 框架。包括前端和后端两部分，以及对于不支持 BigPipe 模式的流量启用的降级模式。此外，为了便于 SEO，对于搜索引擎 Spider 的抓取也要使用降级模式。</li>
  <li>Pagelet 和 DataProvider 管理维护制度。这是一项管理上的措施，主要是为了管理 Pagetlet、DataProvider 以及其之间的依赖关系。</li>
  <li>BigPipe 调试工具。由于在 BigPipe 开发模式中，后端开发负责 DataProvider，前端人员负责 Pagelet，双方需要调试工具进行独立开发调试。</li>
</ol>

<h3 id="潜在问题">潜在问题</h3>

<ol>
  <li>页面交叉调用过多，导致分段输出效果并不好</li>
  <li>前端的误调用会影响后端的响应时间</li>
  <li>后端性能优化需要前端配合</li>
</ol>

<h3 id="异步并行框架">异步并行框架</h3>

<p>由于贴吧现有框架本身并不支持纯异步调用，只支持阻塞并行的远程调用(ral_multi)，其响应时间为：</p>

<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>t</mi><mn>1</mn><mo separator="true">,</mo><mi>t</mi><mn>2</mn><mo separator="true">,</mo><mi>t</mi><mn>3...</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">
t = max(t1, t2, t3...)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault">t</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">t</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">t</span><span class="mord">3</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mclose">)</span></span></span></span></p>

<p>框架本身需要升级，在升级完成前需要基于现有架构模拟纯异步，并且要在框架支持纯异步后，平滑对 DataProvider 透明地迁移成纯异步模式。</p>

<p>因此，BigPipe 并行框架采用异步-回调模式，通过状态机模拟异步过程。状态机会以深度优先遍历 DataProvider 以及其依赖的 DataProvider，并初始化成 <code class="language-plaintext highlighter-rouge">INITIAL</code> 状态。没有依赖的 DataProvider 会直接执行，进入 <code class="language-plaintext highlighter-rouge">EXECUTING</code> 状态。当一个有依赖的 DataProvider 的依赖已经全部处于 <code class="language-plaintext highlighter-rouge">READY</code> 状态时，则会同一般的 DataProvider 一样 <code class="language-plaintext highlighter-rouge">execute</code> 执行。<code class="language-plaintext highlighter-rouge">execute</code> 函数中会有数据交互和业务逻辑处理，当处理完毕后需要主动调用 <code class="language-plaintext highlighter-rouge">ready</code> 函数将 DataProvider 自身置为 <code class="language-plaintext highlighter-rouge">READY</code>。</p>

<p>Pagelet 依赖的 DataProvider 都 <code class="language-plaintext highlighter-rouge">READY</code> 后，就会渲染页面。</p>

<h3 id="buffer问题">Buffer问题</h3>

<p>由于“各路” buffer 的存在，如果包比较小的话 BigPipe 的 chunked 输出很可能会被 buffer 住。针对这种情况，一般来说有两种方式。</p>

<ol>
  <li>使用 <code class="language-plaintext highlighter-rouge">str_pad</code> 这类函数进行填充，如：填充空格。永远将一次 flush 的数据填充到 <code class="language-plaintext highlighter-rouge">buffer_size</code>。</li>
  <li>调小 buffer，让数据更容易达到 <code class="language-plaintext highlighter-rouge">buffer_size</code>。</li>
  <li>关闭 buffer。</li>
</ol>

<p>对于 Nginx 来说，会有 <code class="language-plaintext highlighter-rouge">proxy_buffer</code> 和 <code class="language-plaintext highlighter-rouge">fastcgi_buffer</code>。第一种方式，不用调整 buffer，但这种方式很不优雅，而且增加了带宽，并不是很合理。至于调小 buffer，这看起来是一个很好的思路，然而对于 gzip 过的数据来说，最小的 buffer 可能也比较大。因此，我们选择了关闭 <code class="language-plaintext highlighter-rouge">proxy_buffer</code> 和 <code class="language-plaintext highlighter-rouge">fastcgi_buffer</code>。</p>

<p>然而，这样带来了一个问题。线上运行中的 Nginx 1.4.4版本过低，关闭 <code class="language-plaintext highlighter-rouge">proxy_buffer</code> 的指令 <code class="language-plaintext highlighter-rouge">proxy_buffering off</code> 原生就支持。而关闭 <code class="language-plaintext highlighter-rouge">fastcgi_buffer</code> 的 <code class="language-plaintext highlighter-rouge">fastcgi_buffering</code> 需要1.5.6版本。所以首先，我们把 Nginx 版本升级到了1.7.8，重编译后上线。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Syntax: fastcgi_buffering on | off;
Default: fastcgi_buffering on;
Context: http, server, location
This directive appeared in version 1.5.6.
</code></pre></div></div>

<p>详见 <a href="http://nginx.org/en/docs/http/ngx_http_fastcgi_module.html#fastcgi_buffering">http://nginx.org/en/docs/http/ngx_http_fastcgi_module.html#fastcgi_buffering</a></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># 旧版本的Nginx并不支持fastcgi_buffering
nginx: [emerg] unknown directive "fastcgi_buffering"
</code></pre></div></div>

<p>还有一个问题，就是我们并不想对所有请求都关闭 buffer。为了将影响面做得最小，我们只想关闭特定模块的 buffer。改 <code class="language-plaintext highlighter-rouge">nginx.conf</code> 固然可以实现，不过对于不支持嵌套 <code class="language-plaintext highlighter-rouge">if</code> 的 <code class="language-plaintext highlighter-rouge">nginx.conf</code> 来说这是个很不舒服的用法。</p>

<p>幸好，在升级的过程中，发现了一个刚好可以用 http header，用于关闭 buffer。</p>

<blockquote>
  <p>Buffering can also be enabled or disabled by passing “yes” or “no” in the “X-Accel-Buffering” response header field. This capability can be disabled using the fastcgi_ignore_headers directive.</p>
</blockquote>

<p>因此，配置上完全不用关闭 buffer，只需要在 php 代码中加 header 就好，顺利把 buffer 优雅关闭。</p>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">header</span><span class="p">(</span><span class="s1">'X-Accel-Buffering: no'</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="效果评估">效果评估</h3>

<ul>
  <li>TTFB时间减少56% (TTFB: time to first byte)</li>
  <li>白屏时间减少59%</li>
  <li>降低了局部刷新开发成本</li>
</ul>

<h3 id="其它总结">其它总结</h3>

<ul>
  <li>开发迁移时间超长，从立项到上线总共持续了半年，前端主要开发人员因为离职等原因换了三波</li>
  <li>底层本质上还无法并发，优化效果远远不够彻底</li>
  <li>pagelet 交叉请求比较多，效果没有那么好</li>
</ul>

        </div>
        <div class="article-share">
          <a href="https://twitter.com/share?url=https%3A%2F%2Fcrispgm.com%2Fpage%2Fbigpipe-practice.html&text=%E8%B4%B4%E5%90%A7+BigPipe+%E5%AE%9E%E8%B7%B5+%28nginx+%2B+hhvm%29">
            <i class="icon-twitter"></i>
          </a>
          
          <a href="tg://msg_url?url=https%3A%2F%2Ft.me%2Fiv%3Furl%3Dhttps%253A%252F%252Fcrispgm.com%252Fpage%252Fbigpipe-practice.html%26rhash%3Da3e6c7b51eec6a">
            <i class="icon-telegram"></i>
          </a>
          <a href="https://www.buymeacoffee.com/crispgm">
            <i class="icon-coffee"></i>
          </a>
        </div>
        <div id="disqus_thread" class="article-comment"></div>
        <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
      </div>
    </div>
    <footer class="wrapper" id="contact">
  <div class="content">
    <div class="contact">
      <div class="contact-links">
        <a href="mailto:crispgm+web@gmail.com"><i class="icon-envelope-o"></i></a>
        <a href="/feed.xml"><i class="icon-rss"></i></a>
        <a href="https://github.com/crispgm"><i class="icon-github"></i></a>
        <a href="https://stackoverflow.com/users/6858150/david-zhang/"><i class="icon-stack-overflow"></i></a>
        <a href="https://instagram.com/crispgm"><i class="icon-instagram"></i></a>
        <a href="https://twitter.com/crispgm"><i class="icon-twitter"></i></a>
      </div>
      <div class="contact-copyright">
        <a href="https://crispgm.com">David Zhang</a> &copy; 2022
      </div>
    </div>
  </div>
</footer>

    
<script src="/assets/scripts/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>


    
<script>
var disqus_config = function () {
  this.page.identifier = '/page/bigpipe-practice.html';
};

(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://crispgm.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>


  </body>
  <script>
document.addEventListener('scroll', function(e) {
  var wrapper   = document.querySelector('.blog-wrapper');
  var article   = document.querySelector('.article');
  var docHeight = wrapper.offsetHeight;
  var maxHeight = docHeight - window.innerHeight - article.offsetTop;
  var scrollTop = window.scrollY || window.scollTop || document.getElementsByTagName("html")[0].scrollTop;
  var ratio = scrollTop / maxHeight;
  var progressBar = document.querySelector('.progress-bar');
  var winWidth  = window.innerWidth;
  if (ratio <= 1.0) {
    progressBar.style.width = winWidth * ratio + 'px';
  }
  else {
    progressBar.style.width = winWidth + 'px';
  }
});
</script>

  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-50708664-1', 'auto');
  ga('send', 'pageview');
</script>
</html>
