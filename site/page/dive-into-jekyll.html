<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <meta name="keywords" content=""/>
    <meta name="description" content="A minimalist programmer, photographer and lifes lover."/>
    <title>深入 Jekyll | DAVID ZHANG</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="icon" type="image/x-icon" href="https://assets-cdn.github.com/favicon.ico">
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="/css/zenburn.css">
    <link rel="stylesheet" href="/css/opensans.css">
    <!-- <link rel="stylesheet" href="/css/font-awesome.min.css"> -->
    <script src="/script/highlight.pack.js"></script>
    <script src="/script/jquery-3.1.0.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </head>
  <body>
    <div id="content">
    <header class="menu">
      <div class="menu-home">
        <a href="/" style="color: #000000;">DAVID ZHANG</a>
      </div>
      <div class="menu-links">
        <div class="menu-item">
          <a href="/blogs.html">BLOGS</a>
        </div>
        <div class="menu-item">
          <a href="/projects.html">PROJECTS</a>
        </div>
        <div class="menu-item">
          <a href="/things.html">THINGS</a>
        </div>
        <div class="menu-item">
          <a href="/about.html">ABOUT</a>
        </div>
      </div>
    </header>
<div class="article">
  <div class="article-head">
    <div class="article-title">深入 Jekyll</div>
    <div class="article-date">August 18, 2016</div>
  </div>
  <div class="article-main">
    <h1 id="section">介绍</h1>

<p>Jekyll 是一个为博客设计的静态网站生成器，也可以用于个人、项目或组织的网站构建。可以认为，Jekyll 是一个基于文件的内容管理系统（CMS）。它使用 Ruby 编写，通过 Markdown 和 Liquid 模板生成内容。</p>

<p>有了 Jekyll 这类静态博客生成工具，我们不再需要使用动态语言开发和运行后端程序（如：Wordpress 和 Drupal 等），而只是需要一个静态 HTTP Server。甚至，在有了 GitHub Pages 后，连服务器资源都可以省去。当然，静态网站的好处不止是节省资源，还有安全、速度、扩展性等考虑。具体可以阅读文章：<a href="https://www.netlify.com/blog/2016/05/18/9-reasons-your-site-should-be-static">https://www.netlify.com/blog/2016/05/18/9-reasons-your-site-should-be-static</a>。</p>

<p>美国总统奥巴马连任时的竞选 <a href="http://kylerush.net/blog/meet-the-obama-campaigns-250-million-fundraising-platform/">Campaign</a> 网站就使用 Jekyll 开发。ps：不过，希拉里的技术团队又退回到了动态网站。</p>

<p>GitHub Pages 的背后就运行着 Jekyll，而 Jekyll 本身也是由 GitHub co-founder、前 CEO Tom Preston-Werner(@mojombo) 创立，目前由 Parker Moore(@parkr) 维护，他本人也于<a href="https://byparker.com/blog/2016/joining-github/">2016年初加入了 GitHub</a>。</p>

<p>在 GitHub 的支持下，Jekyll 社区一直保持着极为活跃的状态，Jekyll 的 GitHub Repo 每天都处于更新的状态。近期，刚刚发布了 3.2.0 版本，开始支持基于 RubyGems 的主题。</p>

<p>但 3.2.0 版和作为修补的 3.2.1 版本生态还不是很完善，原有的主题大多还没有完成 Gem 化改造。官方目前没有主题分享的网站，第三方主题资源分享网站也基本都没有升级，所以反而难以用新的方式选择主题。</p>

<p>此外，主题 Gem 化带来的好处主要是主题分发的便捷性，但如果需要动手改动主题中的 css 或者 <code class="highlighter-rouge">_layout</code> 文件，就比较麻烦。</p>

<p>所以在短期内，我还是比较推荐使用原有的 3.1.6 版本的模式。当然，即使程序是 3.2.1 版本也可以按旧的方式来，因为 Jekyll 是向下兼容的。</p>

<h1 id="section-1">快速入门</h1>

<h4 id="section-2">安装</h4>

<p>一般的标准 Linux 和 Mac 环境，都已经自带 Ruby 和 RubyGems。因此直接使用 gem 进行安装：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>gem install jekyll
</code></pre>
</div>

<h4 id="section-3">建立一个博客</h4>

<p>假设博客名为 myblog:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>jekyll new myblog
</code></pre>
</div>

<h4 id="section-4">撰写内容</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>cd myblog
</code></pre>
</div>

<h4 id="section-5">调试</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>jekyll serve
</code></pre>
</div>

<p>详细的使用教程可以参考<a href="https://jekyllrb.com/docs/home/">官方文档</a>。</p>

<h1 id="github-pages">GitHub Pages</h1>

<p>GitHub Pages 是 GitHub 推出的一项为方便程序员建立项目主页的服务，它的后端实质是用静态服务和 Jekyll。我们可以建立名为 yourname.github.io 的 repo，并在里面放入 Jekyll 或者静态代码。</p>

<p>对于 Jekyll，我们不需要执行 build，只需要把源文件都提交上去就可以访问生成后的静态页面。</p>

<h1 id="section-6">高级玩法</h1>

<h2 id="liquid-templates">Liquid Templates</h2>

<p>Jekyll 的底层模板层渲染基于开源 Ruby 库 <a href="https://shopify.github.io/liquid/">Liquid</a> 实现。这是一个 <a href="https://www.shopify.com/">Shopify</a> 公司开源出来的模版系统，用于 Shopify 的店铺主题系统。</p>

<p>Liquid 提供 Objects(对象)，Tags(标签)和 Filters(过滤器) 三种类型的模板标记。</p>

<h3 id="objects">Objects</h3>

<p><strong>Objects</strong> 就是传统意义上的模板变量，用双大括号包围。Jekyll 就是将文件中解析的各种内容，通过 Liquid Objects 注入给展示层。</p>

<p>如下，表示页面的标题：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="p">{</span><span class="err">{</span><span class="w"> </span><span class="err">page.title</span><span class="w"> </span><span class="p">}</span><span class="err">}</span><span class="w">
</span></code></pre>
</div>

<h3 id="tags">Tags</h3>

<p><strong>Tags</strong> 主要用于提供逻辑功能和控制流，Liquid 自带的 Tags 大多都是控制流和变量相关的，如：if/foreach/assign/capture 之类的。但 Tags 实际上可以用作增加新的标签，作为逻辑功能函数的感觉。</p>

<p>Jekyll 就有一种扩展是通过扩展 Liquid Tags 来实现。</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="p">{</span><span class="err">%</span><span class="w"> </span><span class="err">if</span><span class="w"> </span><span class="err">user</span><span class="w"> </span><span class="err">%</span><span class="p">}</span><span class="w">
  </span><span class="err">Hello</span><span class="w"> </span><span class="p">{</span><span class="err">{</span><span class="w"> </span><span class="err">user.name</span><span class="w"> </span><span class="p">}</span><span class="err">}!</span><span class="w">
</span><span class="p">{</span><span class="err">%</span><span class="w"> </span><span class="err">endif</span><span class="w"> </span><span class="err">%</span><span class="p">}</span><span class="w">
</span></code></pre>
</div>

<h3 id="filters">Filters</h3>

<p><strong>Filters</strong> 写法和效果都可以类比于 Shell 中的 Pipe 模式。输出的变量，通过管道符传递进行链式处理。Jekyll 官方扩展了一批 Liquid Filters 配合 Liquid Objects，便于实现博客系统。如：博客的排序、日期的格式化等。</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="p">{</span><span class="err">{</span><span class="w"> </span><span class="nt">"/my/fancy/url"</span><span class="w"> </span><span class="err">|</span><span class="w"> </span><span class="err">append</span><span class="p">:</span><span class="w"> </span><span class="s2">".html"</span><span class="w"> </span><span class="p">}</span><span class="err">}</span><span class="w">
</span></code></pre>
</div>

<p>注：以上例子均取自 <a href="https://shopify.github.io/liquid/basics/introduction/">Liquid 官方文档</a>。</p>

<h2 id="jekyll-data">Jekyll Data</h2>

<p>Jekyll 虽然无法像动态网站程序一样读取数据库，但它提供了一种读取静态数据的方式，就是 Jekyll Data。</p>

<p>我们可以在 Jekyll Data 中使用 YAML, JSON 或 CSV 格式的文件，实现类似动态配置的效果。这些数据会被解析成变量 <code class="highlighter-rouge">site.data.your_data</code> 在 Liquid 模板中使用。</p>

<h1 id="section-7">扩展</h1>

<h2 id="jekyll-themes">Jekyll Themes</h2>

<h2 id="jekyll-plugins">Jekyll Plugins</h2>

<p>Jekyll 支持多种扩展方式，分别是 Generators, Converters, Commands, Tags 和 Hooks。其中一些是 Jekyll 自身的扩展机制，而 Tags 则实质上是对 Liquid Tags 进行扩展。</p>

<p>扩展可以通过 Gem 或本地文件分发使用，这块的生态比较杂，主要还是通过 Jekyll 主页 Jekyll Plugins 文档的专门区域分享插件。对于插件开发者来说，完成开发后可以发 PR 修改 Jekyll Plugins 页面把你的插件分享出来，一般都会被准许 merge（<del>想骗贡献的速来</del>）。</p>

<h1 id="jekyll-">Jekyll 社区</h1>

<p>Jekyll 的社区非常繁荣，迭代很快，并且受到 GitHub 官方的支持。</p>

<p>Jekyll 的自动化测试覆盖率非常高，既有基于 Cucumber 实现的 Bahavior Driven Test，也有一般的 Unit Test，通过常见的 Travis-CI 完成持续集成回归。目前，Jekyll 正在积极接入 AppVeyor，也就是 Windows 领域的 Travis-CI。很快即将实现多端（类 Unix 系统，如Linux/Mac 和 Windows 系统）、多平台（原生 Ruby 和 JRuby）自动化回归。</p>

<p>Jekyll 不仅测试做到了自动化，还做到了整体工作流的自动化。Jekyll 启用了 @jekyllbot 辅助项目维护团队：</p>

<ul>
  <li>Merge PR：通过在 PR 中 <code class="highlighter-rouge">@jekyllbot: merge +site</code> 控制合并，并且在合并后机器人会自动根据后缀内容将变更加入到 changelog 中。</li>
  <li>版本发布：会在 GitHub 打 tag 并发布 release；自动更新并 push gemspec 文件到 RubyGems；获取这个版本内的所有变更贡献者，加入到版本发布新闻的感谢列表中。</li>
</ul>

<h1 id="section-8">启发</h1>

<p>受到了 Jekyll 的启发，我也进行了很多关于工作流自动化方面的思考。主要做了几件小事：</p>

<h4 id="section-9">博客自动化部署</h4>

<p>由于种种原因，我的博客并没有部署在 GitHub Pages 上，而是独立的主机。因此，在 push 到 GitHub 之后还需要部署到主机中。我们可以在主机上起一个代码更新部署进程，在 push 后通过 GitHub WebHooks 回调主机上的更新接口，实现自动化部署。这样，只要一 push 代码就会触发主机上的更新。</p>

<p>为了让 push 本身更容易，又通过 <code class="highlighter-rouge">Rakefile</code> 将 <code class="highlighter-rouge">jekyll build</code> 和 push 也自动化，完成 build 之后自动提交如：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>git commit -m "Deployed at 2016-08-18 14:50:26 +0800"

git push origin master
</code></pre>
</div>

<h4 id="section-10">日报/周报邮件模板</h4>

<p>日常工作中，需要每天或每周发送各类日报和周报。发送的内容一般会维护在某个表格或文档中，但邮件的收件人和抄送都是固定的一类人，标题则是标题+时间的格式，正文会有开头问好和结尾签名。这恰好是模板类需求，可以用 Liquid 实现。</p>

<p>对于邮件人和抄送人，建立一些 Group，并且通过 Liquid Tags 返回这些人的邮件地址。如：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>to: '{% group_members tech_core members %}'
</code></pre>
</div>

<p>对于标题，则使用 Liquid Objects 传入时间等变量，并使用 Liquid Filters 将时间转换为合适的样式。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>title: '项目日报 {{ created_time | date: "%Y%m%d" }}' 
</code></pre>
</div>

  </div>
  
  <div class="article-tag">
    
    <div class="tag-item">
    Jekyll
    </div>
    
    <div class="tag-item">
    Ruby
    </div>
    
    <div class="tag-item">
    GitHub
    </div>
    
    <div class="tag-item">
    Blog
    </div>
    
    <div class="tag-item">
    Markdown
    </div>
    
    <div class="tag-item">
    Liquid
    </div>
    
  </div>
  
  <div id="disqus_thread"></div>
  <script>
  var disqus_config = function () {
      this.page.url = 'https://crispgm.com/page/dive-into-jekyll.html';
      this.page.identifier = '/page/dive-into-jekyll.html';
      this.page.title = '深入 Jekyll';
  };
  (function() {
    var d = document, s = d.createElement('script');
      s.src = '//crispgm.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
  })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
</div>

    <footer>
      <div>Copyright &copy; David Zhang, 2016.</div>
    </footer>
    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-50708664-1', 'auto');
  ga('send', 'pageview');

</script>

    </div>
  </body>
</html>